# toggle side menu 구현

- toggle side menu를 구현할 때 openMenu와 closeMenu 두가지 클릭 이벤트를 만들어 side menu가 열리고 닫히는 것을 제어하려고 했다.
  처음에는 NavMenu 컴포넌트가 만들어내는 domString을 묶어서 그 container에 open이라는 클래스를 추가하고 제거하려고 했는데, 하위 컴포넌트에서 만들어지는 domString 정보를 상위 컴포넌트가 알고 있는것이 이상하다 생각해 MainNav를 묶고있는 mani-nav에 class를 추가하도록 바꿔주었다.
- 추가로 closeMenu 이벤트를 하위 컴포넌트로 전달했을 때, side menu가 아닌 부분을 클릭했을 때 closeMenu 이벤트가 실행 되도록 하기 위해 overlay라는 div를 만들어 side menu보다 작은 z-index값을 줌을 통해 클릭이벤트를 걸어줄 selcetor를 만들어주었다.

# Page Component에서 서버에서 데이터 전달 받을 때 비동기 처리

- App이 아닌 Page Component에서 Page Component가 불릴 때마다 서버에서 데이터를 받아 하위 컴포넌트에게 전달해 domString을 만드는 구조로 코드를 작성했다. 이 때 서버에서 데이터를 전달받는 것을 기다려야 하기 때문에 async-await을 사용했는데 render 함수에 async를 사용하니 원했던 domString을 바로 반환하는것이 아닌 Promise를 반환하는 문제가 발생했다.
- 이를 해결하기위해 return을 받아서 처리하는 함수도 async-await을 사용해 Promise를 처리할 수 있도록 해주었다.

# 댓글을 입력하지 않아도 등록이 되는 문제

- 처음에 댓글을 입력하는 textarea의 값이 존재하는지 validation을 해주지 않아서, 댓글을 입력하지 않아도 댓글 작성이 되어버리는 문제가 발생했다.
- 이를 해결하기 위해 `textarea.value.trim()` 한 값이 빈 문자열인지 확인하는 과정을 추가해 주었다.

# 페이지들마다 보여주어야 하는 요소가 다른 문제

- 페이지들마다 로그인여부, 글 작성자의 여부 등을 확인해 렌더링되어야 하는 요소를 다르게 해주어야했다.
- 이를 해결하기 위해 서버로부터 accessUser인지, canEdit인지를 boolean값으로 받아 필요한 요소를 domString으로 만들게 해주었다.

# 스크롤 이벤트가 계속해서 존재하는 문제

- 메인 페이지에서 무한스크롤을 구현하기 위해 window에 scroll event를 사용했는데, 메인 페이지 컴포넌트의 인스턴스를 생성 할때 이전 인스턴스의 이벤트가 남아있는 문제가 존재했다.
- 이를 해결하기위해 새로 인스턴스를 만들때, removeEventListener를 통해 이미 존재하는 scroll event를 제거하려고 했다. 하지만 걸어준 eventhandler에 this가 bind 되어있어서 handler의 주소값이 달라져 remove가 안되었다.

  ```js
    addScrollEvent() {
      window.addEventListener('scroll', this.scrollEvent.bind(this));
    }

    removeScrollEvent() {
      window.removeEventListener('scroll', this.scrollEvent.bind(this));
    }
  ```

- eventhandler에 this를 bind한 것을 변수로 선언해 이 변수를 add하고 remove 함으로써 해결해 주었다.

  ```js
   bindScrollEvent = this.scrollEvent.bind(this);

    addScrollEvent() {
      window.addEventListener('scroll', this.bindScrollEvent);
    }

    removeScrollEvent() {
      window.removeEventListener('scroll', this.bindScrollEvent);
    }
  ```

# 존재하지 않는 post로 url접근시 빈 화면을 렌더링하는 문제

- `/post/:postId`의 url로 각 post에 접근할 수 있는데 존재하지 않는 postId 입력시에 NotFound Page를 렌더링하는 것이 아니라 빈 화면을 렌더링하는 문제가 발생했다.
- 이를 해결하기 위해 Post Page가 렌더링될 때 서버로부터 받아오는 post가 존재하지 않는다면 history.pushState를 통해 NotFound Page를 렌더링하고 다시 원래의 path로 바꿔주었다.

  ```js
    async render() {
      const path = window.location.pathname;
      const pathId = +path.split('/')[2];

      const { accessUser, canEdit, post } = await this.getPost(pathId);

      if (!post) {
        window.history.pushState(null, null, '/wrongpost');
        this.setState();
        window.history.pushState(null, null, path);
      }
      ...
    }
  ```
